#!/bin/sh

PROGRAM_NAME="quick-backup-cli"
VERSION="v1.6"

CONFIG_DEST="$1"
CONFIG=$HOME/.config/
PROGRAMS_CSV="$CONFIG""$PROGRAM_NAME"/programs.csv

add_trailing_slash_to_dir_if_not() {
	if ! echo "$1" | grep -q '\b/$'; then
		echo "$1/"
	fi
}

check_dir_exists() {
	if [ ! -d "$1" ]; then
		printf "Error: The directory '%s' does not exist.\n" "$1"
		exit 1
	fi
}

if [ ! -d "$1" ]; then
	printf "Usage: %s [DIRECTORY]\n" $PROGRAM_NAME
	printf "Try '%s --help' for more information.\n" $PROGRAM_NAME
	exit 1
else
	CONFIG_DEST=$(add_trailing_slash_to_dir_if_not "$CONFIG_DEST")
fi

version_info() {
	printf "%s %s\n" $PROGRAM_NAME $VERSION
	exit 0
}

help_info() {
	printf "Usage: %s [DIRECTORY]
Example: %s ~/Drive/Backups/

Options:
  -v, --version
    Show the version of the script
  -h, --help
    Show this help message and exit\n" $PROGRAM_NAME $PROGRAM_NAME
	exit 0
}

if [ "$1" = "--version" ] || [ "$1" = "-v" ]; then
	version_info
fi

if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
	help_info
fi

trash_and_copy() {
	# If directory $2 and $3 do not exist, then check_dir_exists will
	# cause the code to exit, therefore, only trash if both of them exist
	if [ -d "$1" ] && [ -d "$2" ] && [ -d "$3" ]; then
		trash "$1"
		printf "Sent '%s' to the trash.\n" "$1"
	fi

	# Make sure that cp is successful
	check_dir_exists "$2"
	check_dir_exists "$3"

	cp -r "$2" "$3"
	printf "Copied '%s' to '%s'.\n" "$2" "$3"
}

get_confirmation() {
	printf "This will trash '%s' (if it exists) and copy '%s' to '%s'.\n" "$1" "$2" "$3"
	printf "Are you sure? y/n\n"
	read -r confirmation
	if [ ! "$confirmation" = "y" ] && [ ! "$confirmation" = "Y" ]; then
		printf "Aborted."
		exit 0
	fi
}

print_programs() {
	printf "Select a program (number):\n"
	num=1
	while IFS="," read -r program_name _; do
		printf "%s. %s\n" "$num" "$program_name" | sed 's/\///g'
		num=$((num + 1))
	done <"$PROGRAMS_CSV"
}

configure() {
	printf "Enter program directory name (e.g. retroarch):\n"
	read -r program_name
	printf "Enter program config directory (e.g. /home/user/.config):\n"
	read -r program_directory

	program_name=$(add_trailing_slash_to_dir_if_not "$program_name")
	program_directory=$(add_trailing_slash_to_dir_if_not "$program_directory")

	check_dir_exists "$program_directory"
	check_dir_exists "$program_directory$program_name"

	mkdir -p "$CONFIG""$PROGRAM_NAME"
	echo "$program_name,$program_directory" >>"$PROGRAMS_CSV"

	printf "Added %s!\n" "$program_name" | sed 's/\///g'
}

backup() {
	get_confirmation "$CONFIG_DEST$1" "$2$1" "$CONFIG_DEST"
	printf "Backing up...\n"
	trash_and_copy "$CONFIG_DEST$1" "$2$1" "$CONFIG_DEST"
	printf "Done!\n"
}

download() {
	get_confirmation "$2$1" "$CONFIG_DEST$1" "$2"
	printf "Downloading...\n"
	trash_and_copy "$2$1" "$CONFIG_DEST$1" "$1"
	printf "Done!\n"
}

backup_or_download() {
	print_programs
	read -r program_num
	program_name=$(sed -n "$program_num"p "$PROGRAMS_CSV" | cut -f1 -d",")
	program_directory=$(sed -n "$program_num"p "$PROGRAMS_CSV" | cut -f2 -d",")

	if [ "$program_name" = "" ] || [ "$program_directory" = "" ]; then
		printf "Error: Invalid program"
		exit 1
	fi

	if [ "$1" = "backup" ]; then
		backup "$program_name" "$program_directory"
	elif [ "$2" = "download" ]; then
		download "$program_name" "$program_directory"
	fi
}

select_an_option() {
	printf "Select an option (number):\n"
	printf "1. Configure\n"
	printf "2. Backup\n"
	printf "3. Download\n"
	read -r option

	if [ "$option" = "1" ]; then
		configure
	elif [ "$option" = "2" ]; then
		backup_or_download "backup"
	elif [ "$option" = "3" ]; then
		backup_or_download "download"
	else
		printf "Error: Invalid option.\n"
	fi
}

select_an_option
